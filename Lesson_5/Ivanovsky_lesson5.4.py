# Создать (не программно) текстовый файл со следующим содержимым:
# One — 1
# Two — 2
# Three — 3
# Напишите программу, открывающую файл на чтение и считывающую построчно данные.
# При этом английские числительные должны заменяться на русские.
# Новый блок строк должен записываться в новый текстовый файл.

# я решил усложнить задачу и построить функцию, которая выдаёт название числительного на русском
# для любого трёхзначного числа
# В принципе можно расширить подход для тысяч, миллионов, миллиардов, триллионов и т.д., но я и так
# злоупотребил вашим вниманием, не буду дальше перегружать задание

def num3_to_rus_word(number):
    """ Преобразует трёхзначное число в русское числительное

    :param number: трёхзначное число
    """
    # Сперва нам понадобятся списки названий цифр в каждом разряде

    # В обычной жизни мы не нумеруем списки начиная с нуля. Чтобы соотнести цифру разряда с нужным словом
    # есть два варианта:
    # 1. вычитать из цифры единицу - в коде получается не очень наглядно
    # 2. "сдвинуть" список на один элемент вправо - выглядит проще, так и поступим
    class_hundreds = ["", "сто", "двести", "триста", "четыреста", "пятьсот", "шестьсот", "семьсот", "восемьсот",
                      "девятьсот"]

    # для десятков надо сдвигать список ещё на один элемент вправо, т.к. случай с 1 в этом разряде
    # обрабатывается отдельно
    class_tens = ["", "", "двадцать", "тридцать", "сорок", "пятьдесят", "шестьдесят", "семьдесят", "восемьдесят",
                  "девяносто"]

    # Наши предки похоже считали числа 10-19 магическими (причём почти во всех языках).
    # Придётся обрабатывать их отдельно
    class_10_19 = ["десять", "один", "две", "три", "четыр", "пят", "шест", "сем", "восем", "девят"]
    class_10_19 = [*map(lambda x: x + "надцать" if x != "десять" else x, class_10_19)]

    # а тут забавный момент - ноль на своём месте, т.е. список сдвигать не надо
    class_units = ["ноль", "один", "два", "три", "четыре", "пять", "шесть", "семь", "восемь", "девять"]
    word_constructor = ["", class_units, class_tens, class_hundreds]

    final_word = ""
    if len(str(number)) > 3:
        return None
    for index, str_digit in enumerate(str(number)):
        digital_position = len(str(number)) - index
        digit = int(str_digit)

        # если нам передали 0 - его надо назвать
        # в остальных случаях 0 не называется (например, для 109 или 50)
        # мы застрахованы от ситуации, когда 0 идёт в начале числа (например 019) тем, что в функцию передаётся int
        if (digit == 0) and len(final_word) > 0:
            continue

        # для первого слова в названии числительного пробел не нужен
        final_word += " " if len(final_word) > 0 else ""

        # обрабатываем отдельно числа 10-19
        if digital_position == 2 and digit == 1:
            final_word += class_10_19[number % 10]
            break

        final_word += word_constructor[digital_position][digit]
    return final_word


# Собственно изначальное задание
# Раз я допускаю трёхзначные числа, то выполнять преобразование по английскому названию сложно.
# Но, по изначальному условию задачи у нас есть и название числительного и цифровое представление
# Буду опираться на последнее

with open(r"resources\Numbers_eng.txt") as file_read_obj:
    with open(r"Numbers_rus.txt", "w", encoding="utf8") as file_write_obj:
        for string in file_read_obj:
            number_string_list = string.split(" ")
            number_string_list.reverse()
            file_write_obj.write(
                f"{num3_to_rus_word(int(number_string_list[0])).capitalize()} - {int(number_string_list[0])}\n")
